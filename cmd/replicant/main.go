package main

import (
	"errors"
	"flag"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"runtime/debug"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/joho/godotenv"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/ttab/elephant-api/repository"
	"github.com/ttab/elephant-replicant/internal"
	"github.com/ttab/elephantine"
	"github.com/urfave/cli/v2"
	"golang.org/x/oauth2"
)

func main() {
	err := godotenv.Load()
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		slog.Error("exiting: ",
			elephantine.LogKeyError, err)
		os.Exit(1)
	}

	runCmd := cli.Command{
		Name:        "run",
		Description: "Runs the service",
		Action:      runReplicant,
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "addr",
				EnvVars: []string{"ADDR"},
				Value:   ":1080",
			},
			&cli.StringFlag{
				Name:    "profile-addr",
				EnvVars: []string{"PROFILE_ADDR"},
				Value:   ":1081",
			},
			&cli.StringFlag{
				Name:    "log-level",
				EnvVars: []string{"LOG_LEVEL"},
				Value:   "info",
			},
			&cli.StringFlag{
				Name:     "repository-endpoint",
				EnvVars:  []string{"REPOSITORY_ENDPOINT"},
				Required: true,
				Value:    "http://editorial-repository:1080",
			},
			&cli.StringFlag{
				Name:    "db",
				Value:   "postgres://elephant-replicant:pass@localhost/elephant-replicant",
				EnvVars: []string{"CONN_STRING"},
			},
			&cli.StringSliceFlag{
				Name:    "cors-hosts",
				EnvVars: []string{"CORS_HOSTS"},
			},
			&cli.StringSliceFlag{
				Name:    "ignore-types",
				EnvVars: []string{"IGNORE_TYPES"},
				Usage:   "Document types to ignore when replicating",
			},
			&cli.StringSliceFlag{
				Name:    "ignore-subs",
				EnvVars: []string{"IGNORE_SUBS"},
				Usage:   "Ignore events generated by these client subs.",
			},
			&cli.StringSliceFlag{
				Name:    "ignore-section",
				EnvVars: []string{"IGNORE_SECTIONS"},
				Usage:   "The UUID of sections to ignore prefixed with document type. Example: 'core/event:0730efa9-43f2-468d-979a-aaffc74d7582'", //nolint: lll
			},
			&cli.StringSliceFlag{
				Name:    "include-attachments",
				EnvVars: []string{"INCLUDE_ATTACHMENTS"},
				Usage:   "Attachment references in the format '[name].[document type]', example 'image.core/image'",
			},
			&cli.BoolFlag{
				Name:    "all-attachments",
				EnvVars: []string{"ALL_ATTACHMENTS"},
				Usage:   "Replicate all attachments",
			},
			&cli.Int64Flag{
				Name:    "start-event",
				EnvVars: []string{"START_EVENT"},
				Usage:   "The event to start replication at",
			},
			&cli.StringFlag{
				Name:    "target-oidc-config",
				EnvVars: []string{"TARGET_OIDC_CONFIG"},
			},
			&cli.StringFlag{
				Name:    "target-client-id",
				EnvVars: []string{"TARGET_CLIENT_ID"},
			},
			&cli.StringFlag{
				Name:    "target-client-secret",
				EnvVars: []string{"TARGET_CLIENT_SECRET"},
			},
			&cli.StringFlag{
				Name:    "target-repository-endpoint",
				EnvVars: []string{"TARGET_REPOSITORY_ENDPOINT"},
			},
		},
	}

	runCmd.Flags = append(runCmd.Flags, elephantine.AuthenticationCLIFlags()...)

	app := cli.App{
		Name:  "elephant-replicant",
		Usage: "The Elephant replicant",
		Commands: []*cli.Command{
			&runCmd,
		},
	}

	if err := app.Run(os.Args); err != nil {
		slog.Error("failed to run application",
			elephantine.LogKeyError, err)
		os.Exit(1)
	}
}

var (
	sourceScopes = []string{"doc_read_all", "eventlog_read"}
	targetScopes = []string{"doc_admin"}
)

func runReplicant(c *cli.Context) error {
	var (
		addr               = c.String("addr")
		profileAddr        = c.String("profile-addr")
		logLevel           = c.String("log-level")
		repositoryEndpoint = c.String("repository-endpoint")
		targetEndpoint     = c.String("target-repository-endpoint")
		corsHosts          = c.StringSlice("cors-hosts")
		ignoreTypes        = c.StringSlice("ignore-types")
		ignoreSubs         = c.StringSlice("ignore-subs")
		ignoreSections     = c.StringSlice("ignore-section")
		includeAttachments = c.StringSlice("include-attachments")
		allAttachments     = c.Bool("all-attachments")
		startEvent         = c.Int64("start-event")
	)

	if repositoryEndpoint == targetEndpoint {
		return errors.New("source and target cannot be the same")
	}

	logger := elephantine.SetUpLogger(logLevel, os.Stdout)

	var incAttachments []internal.AttachmentRef

	for _, s := range includeAttachments {
		ref, err := internal.AttachmentRefFromString(s)
		if err != nil {
			return fmt.Errorf("invalid 'include-attachments': %w", err)
		}

		incAttachments = append(incAttachments, ref)
	}

	if allAttachments && len(incAttachments) > 0 {
		logger.Warn(
			"running with both 'all-attachments' and 'include-attachments', all attachments will be included")
	}

	defer func() {
		if p := recover(); p != nil {
			slog.ErrorContext(c.Context, "panic during setup",
				elephantine.LogKeyError, p,
				"stack", string(debug.Stack()),
			)

			os.Exit(2)
		}
	}()

	dbpool, err := pgxpool.New(c.Context, c.String("db"))
	if err != nil {
		return fmt.Errorf("create connection pool: %w", err)
	}

	defer func() {
		// Don't block for close
		go dbpool.Close()
	}()

	err = dbpool.Ping(c.Context)
	if err != nil {
		return fmt.Errorf("connect to database: %w", err)
	}

	auth, err := elephantine.AuthenticationConfigFromCLI(c, sourceScopes)
	if err != nil {
		return fmt.Errorf("set up authentication: %w", err)
	}

	_, err = auth.TokenSource.Token()
	if err != nil {
		return fmt.Errorf("verify credentials: %w", err)
	}

	targetAuth, err := targetAuthentication(c, targetScopes)
	if err != nil {
		return fmt.Errorf("set up authentication: %w", err)
	}

	_, err = targetAuth.TokenSource.Token()
	if err != nil {
		return fmt.Errorf("verify target credentials: %w", err)
	}

	elephantClient := oauth2.NewClient(c.Context, auth.TokenSource)
	targetElephantClient := oauth2.NewClient(c.Context, targetAuth.TokenSource)

	documents := repository.NewDocumentsProtobufClient(
		repositoryEndpoint, elephantClient,
	)

	targetDocuments := repository.NewDocumentsProtobufClient(
		targetEndpoint, targetElephantClient,
	)

	server := elephantine.NewAPIServer(logger, addr, profileAddr,
		elephantine.APIServerCORSHosts(corsHosts...))

	err = internal.Run(c.Context, internal.Parameters{
		Server:             server,
		Logger:             logger,
		Database:           dbpool,
		Documents:          documents,
		TargetDocuments:    targetDocuments,
		CORSHosts:          corsHosts,
		IgnoreTypes:        ignoreTypes,
		IgnoreSubs:         ignoreSubs,
		IgnoreSections:     ignoreSections,
		IncludeAttachments: incAttachments,
		AllAttachments:     allAttachments,
		MinEventID:         startEvent,
		MetricsRegisterer:  prometheus.DefaultRegisterer,
		AuthInfoParser:     auth.AuthParser,
	})
	if err != nil {
		return fmt.Errorf("run application: %w", err)
	}

	return nil
}

func targetAuthentication(c *cli.Context, scopes []string) (*elephantine.AuthenticationConfig, error) {
	targetC := cli.NewContext(&cli.App{},
		flag.NewFlagSet("target", flag.ContinueOnError),
		c,
	)

	cpy := []string{
		"oidc-config", "client-id", "client-secret",
	}

	for _, name := range cpy {
		err := targetC.Set(name, c.String("target-"+name))
		if err != nil {
			return nil, fmt.Errorf("set %q in context: %w", name, err)
		}
	}

	return elephantine.AuthenticationConfigFromCLI(c, scopes) //nolint: wrapcheck
}
